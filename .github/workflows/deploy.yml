name: Deploy (SSH via GHCR)

permissions:
  actions: read
  contents: read

on:
  # Manual deploy with overrides
  workflow_dispatch:
    inputs:
      tag:
        description: "Image tag to deploy (default: latest)"
        default: "latest"
        required: false
      public_url:
        description: "Public URL to test (default: https://api.vedacore.io)"
        default: "https://api.vedacore.io"
        required: false
      environment:
        description: "Target environment (production|staging)"
        default: "production"
        required: false
      verify_symbols:
        description: "Run ATS symbol contract checks (true|false)"
        default: "true"
        required: false
  # Auto-deploy when build & push succeeds on main (via repository_dispatch)
  repository_dispatch:
    types: [build-complete]

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Deploy on manual dispatch or auto-deploy via repository_dispatch from main branch builds
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'repository_dispatch'
    environment:
      name: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
      url: ${{ (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging') && 'https://staging.api.vedacore.io' || 'https://api.vedacore.io' }}
    concurrency:
      group: deploy-vedacore-api
      cancel-in-progress: true
    env:
      APP_DIR: /opt/vedacore-api
      PORT: ${{ (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging') && '8000' || '80' }}
      IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/vedacore-api
    steps:
      - name: Compute image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            # Use SHA from build workflow via repository_dispatch payload
            BUILD_SHA="${{ github.event.client_payload.sha }}"
            echo "tag=sha-${BUILD_SHA}" >> "$GITHUB_OUTPUT"
            echo "sha=${BUILD_SHA}" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual: prefer provided tag; if omitted, default to current run SHA
            if [ -n "${{ inputs.tag }}" ]; then
              echo "tag=${{ inputs.tag }}" >> "$GITHUB_OUTPUT"
              # Try to extract sha-XXXX to compare later (best-effort)
              echo "sha=${{ inputs.tag }}" >> "$GITHUB_OUTPUT"
            else
              echo "tag=sha-${{ github.sha }}" >> "$GITHUB_OUTPUT"
              echo "sha=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            fi
          else
            # Fallback
            echo "tag=sha-${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "sha=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve REDIS_URL secret
        id: redis
        env:
          ENV_INPUT: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || '' }}
          REDIS_URL_PROD: ${{ secrets.REDIS_URL }}
          REDIS_URL_STAGING: ${{ secrets.STAGING_REDIS_URL }}
        run: |
          set -euo pipefail
          URL="${REDIS_URL_PROD:-}"
          if [ "${ENV_INPUT:-}" = "staging" ]; then
            if [ -n "${REDIS_URL_STAGING:-}" ]; then
              URL="${REDIS_URL_STAGING}"
            fi
          fi
          echo "url=${URL}" >> "$GITHUB_OUTPUT"
      - name: Deploy on server (pull image)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USER }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || '22' }}
          script_stop: true
          envs: AUTH_JWT_SECRET,CORS_ALLOWED_ORIGINS,GHCR_USERNAME,GHCR_TOKEN,PORT,REDIS_URL,API_KEY_V1_CUTOFF_DATE,AUTH_JWKS_URL,DATABASE_URL,SUPABASE_DATABASE_URL
          script: |
            set -euo pipefail
            IMAGE="ghcr.io/sbrg33/vedacore-api:${{ steps.tag.outputs.tag }}"
            INTENDED_SHA="${{ steps.tag.outputs.sha }}"
            # Check required environment variables
            : ${GHCR_USERNAME:?GHCR_USERNAME not set}
            : ${GHCR_TOKEN:?GHCR_TOKEN not set}
            # AUTH may be provided via JWKS or static secret
            if [ -z "${AUTH_JWT_SECRET:-}" ] && [ -z "${AUTH_JWKS_URL:-}" ]; then
              echo "ERROR: AUTH_JWT_SECRET or AUTH_JWKS_URL must be set" >&2
              exit 1
            fi
            : ${CORS_ALLOWED_ORIGINS:?CORS_ALLOWED_ORIGINS not set}
            # Login to GHCR (read:packages token)
            docker login ghcr.io -u "$GHCR_USERNAME" -p "$GHCR_TOKEN"
            # SECURITY FIX: Ensure firewall blocks direct container access
            if command -v sudo >/dev/null 2>&1 && command -v ufw >/dev/null 2>&1; then \
              echo "Configuring UFW firewall rules (SECURITY HARDENED)..."; \
              # Keep SSH accessible
              sudo ufw allow 22/tcp || true; \
              # Allow Cloudflare proxy ports only
              sudo ufw allow 80/tcp || true; \
              sudo ufw allow 443/tcp || true; \
              # CRITICAL: Block direct container access for production
              if [ "${PORT}" = "80" ]; then \
                echo "üîí PRODUCTION: Blocking direct port 8000 access"; \
                sudo ufw deny 8000/tcp || true; \
              else \
                echo "üìç STAGING: Allowing direct port ${PORT} access"; \
                sudo ufw allow ${PORT}/tcp || true; \
              fi; \
              # Enable UFW on reboot and now
              sudo systemctl enable ufw || true; \
              sudo ufw --force enable || true; \
              sudo ufw reload || true; \
              echo "‚úÖ Firewall configured: Allow 22,80,443 | Block 8000 for production"; \
            fi
            # Stop Apache and nginx to ensure port 80 is available
            systemctl stop apache2 || true
            systemctl stop nginx || true
            # Configure Docker log rotation and cleanup (persistent) - Safe approach
            mkdir -p /etc/docker
            # Write daemon.json with explicit error checking to prevent corruption
            DAEMON_CONFIG='{"log-driver":"json-file","log-opts":{"max-size":"10m","max-file":"3"}}'
            echo "$DAEMON_CONFIG" > /etc/docker/daemon.json.tmp
            if [ $? -eq 0 ] && echo "$DAEMON_CONFIG" | python3 -m json.tool > /dev/null 2>&1; then
              mv /etc/docker/daemon.json.tmp /etc/docker/daemon.json
              echo "‚úÖ Docker daemon.json written successfully"
              systemctl restart docker || true
            else
              echo "‚ùå ERROR: Failed to write valid daemon.json" >&2
              rm -f /etc/docker/daemon.json.tmp
              # Don't fail deployment, but log the issue
              echo "‚ö†Ô∏è  WARNING: Docker daemon.json update failed, using existing config"
            fi
            # Pull & restart container directly on port 80 (bypass nginx)
            docker rm -f vedacore-api || true
            docker pull "$IMAGE"
            # Run with restart policy to persist across host reboots
            # Decide VC_ENV based on DB env presence (default to local if missing)
            VC_ENV_VALUE="remote"
            if [ -z "${DATABASE_URL:-}" ] && [ -z "${SUPABASE_DATABASE_URL:-}" ]; then
              VC_ENV_VALUE="local"
              echo "INFO: DATABASE_URL/SUPABASE_DATABASE_URL not set, using VC_ENV=local"
            fi
            # Ensure API key cutoff date is defined in production (middleware requirement)
            if [ -z "${API_KEY_V1_CUTOFF_DATE:-}" ]; then
              API_KEY_V1_CUTOFF_DATE='2025-08-31'
              echo "INFO: API_KEY_V1_CUTOFF_DATE not set; defaulting to ${API_KEY_V1_CUTOFF_DATE}"
            fi
            docker run -d --name vedacore-api --restart unless-stopped \
              -p ${PORT}:8000 \
              -e ENVIRONMENT=production \
              -e VC_ENV=${VC_ENV_VALUE} \
              -e AUTH_JWT_SECRET="${AUTH_JWT_SECRET}" \
              -e CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS}" \
              -e API_KEY_V1_CUTOFF_DATE="${API_KEY_V1_CUTOFF_DATE}" \
              ${AUTH_JWKS_URL:+ -e AUTH_JWKS_URL="${AUTH_JWKS_URL}"} \
              ${REDIS_URL:+ -e REDIS_URL="${REDIS_URL}"} \
              ${DATABASE_URL:+ -e DATABASE_URL="${DATABASE_URL}"} \
              ${SUPABASE_DATABASE_URL:+ -e SUPABASE_DATABASE_URL="${SUPABASE_DATABASE_URL}"} \
              "$IMAGE"
            # Wait for readiness on direct port access
            i=0; ok=0; \
            while [ $i -lt 45 ]; do \
              if curl -fsS http://127.0.0.1:${PORT}/api/v1/health/ready >/dev/null 2>&1; then ok=1; break; fi; \
              i=$((i+1)); sleep 2; \
            done; \
            if [ $ok -eq 1 ]; then echo "‚úÖ Ready"; else echo "‚ùå Not ready"; docker logs vedacore-api || true; exit 1; fi
            # Verify running build SHA matches intended (best effort)
            RUN_SHA=$(curl -fsS http://127.0.0.1:${PORT}/api/v1/health/version 2>/dev/null | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('build_sha','') or d.get('build',{}).get('sha',''))" 2>/dev/null || echo "")
            if [ -n "$INTENDED_SHA" ] && [ -n "$RUN_SHA" ]; then
              case "$INTENDED_SHA" in
                sha-*) EXPECTED=${INTENDED_SHA#sha-} ;;
                *) EXPECTED=$INTENDED_SHA ;;
              esac
              SHORT_EXPECTED=${EXPECTED:0:7}
              SHORT_RUN=${RUN_SHA:0:7}
              echo "Expected SHA: $SHORT_EXPECTED | Running SHA: $SHORT_RUN"
              if [ "$SHORT_EXPECTED" != "$SHORT_RUN" ]; then
                echo "‚ùå Version mismatch after deploy" >&2
                docker logs vedacore-api || true
                exit 1
              fi
              echo "‚úÖ Version verified"
            else
              echo "‚ö†Ô∏è Could not verify running SHA (missing data)"
            fi
        env:
          AUTH_JWT_SECRET: ${{ secrets.AUTH_JWT_SECRET }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          REDIS_URL: ${{ steps.redis.outputs.url }}
          API_KEY_V1_CUTOFF_DATE: ${{ secrets.API_KEY_V1_CUTOFF_DATE }}

  post-smoke:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Public API smoke test
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            PUBLIC_URL="https://api.vedacore.io"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ inputs.public_url }}" ]; then
              PUBLIC_URL="${{ inputs.public_url }}"
            elif [ "${{ inputs.environment }}" = "staging" ]; then
              PUBLIC_URL="https://staging.api.vedacore.io"
            else
              PUBLIC_URL="https://api.vedacore.io"
            fi
          else
            PUBLIC_URL="https://api.vedacore.io"
          fi
          
          echo "üîç Testing public readiness: $PUBLIC_URL/api/v1/health/ready"
          if curl -fsS "$PUBLIC_URL/api/v1/health/ready" >/dev/null; then
            echo "‚úÖ Public readiness check passed"
          else
            echo "‚ùå Public readiness check failed"
            exit 1
          fi
          
          echo "üîç Testing docs endpoint: $PUBLIC_URL/api/docs"
          if curl -fsS "$PUBLIC_URL/api/docs" >/dev/null; then
            echo "‚úÖ Public docs endpoint accessible"
          else
            echo "‚ùå Public docs endpoint failed"
            exit 1
          fi

          if [ "${{ inputs.verify_symbols || 'true' }}" = "true" ] || [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "üîç ATS symbols acceptance: [\"VEN\",\"MER\"] (should be 200)"
            if curl -fsS -X POST "$PUBLIC_URL/api/v1/ats/transit" \
                 -H 'accept: application/json' -H 'content-type: application/json' \
                 -d '{"targets":["VEN","MER"]}' >/dev/null; then
              echo "‚úÖ ATS symbols accepted"
            else
              echo "‚ùå ATS symbols not accepted"
              exit 1
            fi

            echo "üîç ATS old tokens rejection: [\"MERC\",\"MOON\"] (should be 422)"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$PUBLIC_URL/api/v1/ats/transit" \
                 -H 'accept: application/json' -H 'content-type: application/json' \
                 -d '{"targets":["MERC","MOON"]}')
            if [ "$STATUS" = "422" ]; then
              echo "‚úÖ Old tokens correctly rejected (422)"
            else
              echo "‚ùå Expected 422 for old tokens, got $STATUS"
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è Skipping ATS symbol contract checks (verify_symbols=false)"
          fi
          
          echo "‚úÖ Post-deploy public smoke tests completed successfully"
